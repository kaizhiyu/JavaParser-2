digraph ClassDiagram {
	 fontname = "Bitstream Vera Sans"
	 fontsize = 8

	 node [
		 fontname = "Bistream Vera Sans"
		 fontsize = 8
		 shape = "record"
	 ]

	 edge [
		 fontname = "Bistream Vera Sans"
		 fontsize = 8
	 ]

	 ChangeCollector [
		 label = "{ChangeCollector|# changes : HashMap\l# hierarchy : TypeHierarchy\l|# ChangeCollector(TypeHierarchy) : \l# addAffectedChildren(IJavaElementDelta) : \l# addChange(ICompilationUnit, IJavaElementDelta) : \l# addChange(IImportContainer, IJavaElementDelta) : \l# addChange(IImportDeclaration, IJavaElementDelta) : \l# addChange(IMember, IJavaElementDelta) : \l# addChange(IType, IJavaElementDelta) : \l# addTypeAddition(IType, SimpleDelta) : \l# addTypeChange(IType, int, SimpleDelta) : \l# addTypeRemoval(IType, SimpleDelta) : \l# getAllTypesFromElement(IJavaElement, ArrayList) : \l# getAllTypesFromHierarchy(JavaElement, ArrayList) : \l# hasSuperTypeChange(IType) : boolean\l# hasVisibilityChange(IType) : boolean\l# needsRefresh() : boolean\l# toString() : String\l}"
	 ]

	 HierarchyBinaryType [
		 label = "{HierarchyBinaryType|- modifiers : int\l- sourceName : char\l- name : char\l- enclosingTypeName : char\l- superclass : char\l- superInterfaces : char\l- typeParameterSignatures : char\l- genericSignature : char\l|# HierarchyBinaryType(int, char, char, char, char, char) : \l# getAnnotations() : IBinaryAnnotation\l# getTypeAnnotations() : IBinaryTypeAnnotation\l# getEnclosingMethod() : char\l# getEnclosingTypeName() : char\l# getFields() : IBinaryField\l# getFileName() : char\l# getGenericSignature() : char\l# getInterfaceNames() : char\l# getMemberTypes() : IBinaryNestedType\l# getMethods() : IBinaryMethod\l# getMissingTypeNames() : char\l# getModifiers() : int\l# getName() : char\l# getSourceName() : char\l# getSuperclassName() : char\l# getTagBits() : long\l# isAnonymous() : boolean\l# isBinaryType() : boolean\l# isLocal() : boolean\l# isMember() : boolean\l# recordSuperType(char, char, char) : \l# sourceFileName() : char\l# toString() : String\l# enrichWithExternalAnnotationsFor(ITypeAnnotationWalker, Object, LookupEnvironment) : ITypeAnnotationWalker\l}"
	 ]

	 HierarchyBuilder [
		 label = "{HierarchyBuilder|# hierarchy : TypeHierarchy\l# nameLookup : NameLookup\l# hierarchyResolver : HierarchyResolver\l# infoToHandle : Map\l# focusQualifiedName : String\l+ build : null\l|# HierarchyBuilder(TypeHierarchy, boolean) : \l# buildSupertypes() : \l# connect(IGenericType, IType, IType, IType) : \l# getHandle(IGenericType, ReferenceBinding) : IType\l# getType() : IType\l# lookupBinaryHandle(IBinaryType) : IType\l# worked(IProgressMonitor, int) : \l# createCompilationUnitFromPath(Openable, IFile) : ICompilationUnit\l# getFileName() : char\l# createInfoFromClassFile(Openable, IResource) : IBinaryType\l# createInfoFromClassFileInJar(Openable) : IBinaryType\l}"
	 ]

	 HierarchyResolver [
		 label = "{HierarchyResolver|- focusType : ReferenceBinding\l- superTypesOnly : boolean\l- hasMissingSuperClass : boolean\l# lookupEnvironment : LookupEnvironment\l- options : CompilerOptions\l# builder : HierarchyBuilder\l- typeBindings : ReferenceBinding\l- typeIndex : int\l- typeModels : IGenericType\l- FakeUnit : CompilationUnitDeclaration\l|# null() : \l# HierarchyResolver(INameEnvironment, Map, HierarchyBuilder, IProblemFactory) : \l# HierarchyResolver(LookupEnvironment, HierarchyBuilder) : \l# accept(IBinaryType, PackageBinding, AccessRestriction) : \l# accept(ICompilationUnit, AccessRestriction) : \l# accept(ISourceType, PackageBinding, AccessRestriction) : \l# findSuperClass(IGenericType, ReferenceBinding) : IType\l# findSuperInterfaces(IGenericType, ReferenceBinding) : IType\l# fixSupertypeBindings() : \l# remember(IGenericType, ReferenceBinding) : \l# remember(IType, ReferenceBinding) : \l# rememberAllTypes(CompilationUnitDeclaration, org, boolean) : \l# rememberWithMemberTypes(TypeDeclaration, IType) : \l# reportHierarchy(IType, TypeDeclaration, ReferenceBinding) : \l# reset() : \l# resolve(IGenericType) : \l# resolve(Openable, HashSet, IProgressMonitor) : \l# setEnvironment(LookupEnvironment, HierarchyBuilder) : \l# setFocusType(char) : ReferenceBinding\l# subOrSuperOfFocus(ReferenceBinding) : boolean\l# subTypeOfType(ReferenceBinding, ReferenceBinding) : boolean\l# worked(IProgressMonitor, int) : \l}"
	 ]

	 HierarchyType [
		 label = "{HierarchyType|+ typeHandle : IType\l+ name : char\l+ modifiers : int\l+ superclassName : char\l+ superInterfaceNames : char\l+ anonymous : boolean\l|# HierarchyType(IType, char, int, char, char, boolean) : \l# getFileName() : char\l# getModifiers() : int\l# isBinaryType() : boolean\l# isAnonymous() : boolean\l}"
	 ]

	 PathCollector [
		 label = "{PathCollector|+ MAXTICKS : int\l# cuToHandle : Map\l# scope : IJavaSearchScope\l# binariesFromIndexMatches : Map\l+ names : char\l+ start : int\l+ end : int\l# paths : HashSet\l|# null() : \l# add(char) : \l# retrieve() : char\l# toString() : String\l# IndexBasedHierarchyBuilder(TypeHierarchy, IJavaSearchScope) : \l# build(boolean) : \l# buildForProject(JavaProject, ArrayList, org, HashSet, IProgressMonitor) : \l# compare(Object, Object) : int\l# buildFromPotentialSubtypes(String, HashSet, IProgressMonitor) : \l# createCompilationUnitFromPath(Openable, IFile) : ICompilationUnit\l# createInfoFromClassFile(Openable, IResource) : IBinaryType\l# createInfoFromClassFileInJar(Openable) : IBinaryType\l# determinePossibleSubTypes(HashSet, IProgressMonitor) : String\l# acceptPath(String, boolean) : \l# searchAllPossibleSubTypes(IType, IJavaSearchScope, Map, IPathRequestor, int, IProgressMonitor) : \l# acceptIndexMatch(String, SearchPattern, SearchParticipant, AccessRuleSet) : boolean\l# setCanceled(boolean) : \l# isCanceled() : boolean\l# subTask(String) : \l}"
	 ]

	 RegionBasedHierarchyBuilder [
		 label = "{RegionBasedHierarchyBuilder||# RegionBasedHierarchyBuilder(TypeHierarchy) : \l# build(boolean) : \l# createTypeHierarchyBasedOnRegion(HashMap, IProgressMonitor) : \l# determineOpenablesInRegion(IProgressMonitor) : HashMap\l# injectAllOpenablesForJavaProject(IJavaProject, ArrayList) : \l# injectAllOpenablesForPackageFragment(IPackageFragment, ArrayList) : \l# injectAllOpenablesForPackageFragmentRoot(IPackageFragmentRoot, ArrayList) : \l}"
	 ]

	 RegionBasedTypeHierarchy [
		 label = "{RegionBasedTypeHierarchy|# region : IRegion\l|# RegionBasedTypeHierarchy(IRegion, ICompilationUnit, IType, boolean) : \l# add(IJavaElement) : \l# initializeRegions() : \l# compute() : \l# isAffectedByOpenable(IJavaElementDelta, IJavaElement, int) : boolean\l# javaProject() : IJavaProject\l# pruneDeadBranches() : \l# pruneDeadBranches(IType) : boolean\l# pruneDeadBranches(IType) : \l# removeType(IType) : \l}"
	 ]

	 TypeHierarchy [
		 label = "{TypeHierarchy|+ DEBUG : boolean\l# VERSION : byte\l# SEPARATOR1 : byte\l# SEPARATOR2 : byte\l# SEPARATOR3 : byte\l# SEPARATOR4 : byte\l# COMPUTE_SUBTYPES : byte\l# CLASS : byte\l# INTERFACE : byte\l# COMPUTED_FOR : byte\l# ROOT : byte\l# NO_FLAGS : byte\l# SIZE : int\l# project : IJavaProject\l# focusType : IType\l# workingCopies : ICompilationUnit\l# classToSuperclass : Map\l# typeToSuperInterfaces : Map\l# typeToSubtypes : Map\l# typeFlags : Map\l# rootClasses : TypeVector\l# interfaces : ArrayList\l+ missingTypes : ArrayList\l# NO_TYPE : IType\l# progressMonitor : SubMonitor\l# changeListeners : ArrayList\l+ files : Map\l# packageRegion : Region\l# projectRegion : Region\l# computeSubtypes : boolean\l# scope : IJavaSearchScope\l+ needsRefresh : boolean\l# changeCollector : ChangeCollector\l|# TypeHierarchy() : \l# TypeHierarchy(IType, ICompilationUnit, IJavaProject, boolean) : \l# TypeHierarchy(IType, ICompilationUnit, IJavaSearchScope, boolean) : \l# initializeRegions() : \l# addInterface(IType) : \l# addRootClass(IType) : \l# addSubtype(IType, IType) : \l# addTypeHierarchyChangedListener(ITypeHierarchyChangedListener) : \l# bytesToFlags(byte) : Integer\l# cacheFlags(IType, int) : \l# cacheSuperclass(IType, IType) : \l# cacheSuperInterfaces(IType, IType) : \l# checkCanceled() : \l# compute() : \l# contains(IType) : boolean\l# elementChanged(ElementChangedEvent) : \l# exists() : boolean\l# fireChange() : \l#